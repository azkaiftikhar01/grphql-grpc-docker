# gRPC & GraphQL with Docker

This repository is created to practice and experiment with:
- **gRPC**: A high-performance, open-source universal RPC framework.
- **GraphQL**: A query language for APIs and a runtime for executing those queries.
- **Docker**: A platform to containerize applications and manage dependencies efficiently.

## Objectives
- Learn the basics of Docker and how to containerize Node.js applications.
- Implement and explore gRPC and GraphQL services.
- Practice deploying and running these services in Docker containers.

## Features
- Example gRPC service setup.
- Example GraphQL service setup.
- Dockerfile and Docker Compose for containerization.

## Getting Started
1. Clone the repository:
   ```bash
   git clone https://github.com/azkaiftikhar01/grphql-grpc-docker.git
   cd grphql-grpc-docker
### **Docker Containerization: Comprehensive Notes**

----

### **What is Containerization?**

**Containerization** is the process of packaging software and its dependencies into a lightweight, portable container. These containers can run consistently across various environments, whether it's a developer's laptop, a testing server, or a production environment.

- Containers are isolated from the host system, ensuring consistent execution.
- They are lightweight compared to traditional virtual machines because they share the host OS kernel.

---

### **Key Docker Concepts**

1. **Images**:
   - A Docker image is a lightweight, immutable blueprint for creating containers.
   - Images include the application code, runtime, libraries, and dependencies.

2. **Containers**:
   - A container is a runtime instance of a Docker image.
   - It runs as an isolated process on the host machine.

3. **Dockerfile**:
   - A `Dockerfile` is a script with instructions to build a Docker image.

4. **Volumes**:
   - Docker volumes allow data persistence and sharing between containers.

5. **Docker Swarm**:
   - A built-in orchestration tool for deploying and managing clusters of containers.

---

### **How Dockerfile Works**

A `Dockerfile` is a plain text file containing instructions to build a Docker image. Each instruction creates a new layer in the image. When a `Dockerfile` is processed by the `docker build` command, it generates a new Docker image.

#### **Basic Structure of a Dockerfile**

```dockerfile
# Step 1: Specify the base image
FROM node:14

# Step 2: Set working directory inside the container
WORKDIR /app

# Step 3: Copy package files and install dependencies
COPY package*.json ./
RUN npm install

# Step 4: Copy the rest of the application code
COPY . .

# Step 5: Expose the application port
EXPOSE 3000

# Step 6: Define the command to start the application
CMD ["node", "index.js"]
```

#### **How It Works**
1. **FROM**: Specifies the base image (e.g., `node:14`).
2. **WORKDIR**: Sets the working directory inside the container.
3. **COPY**: Copies files from the host to the container.
4. **RUN**: Executes commands during image build (e.g., installing dependencies).
5. **EXPOSE**: Informs Docker that the container will listen on the specified port.
6. **CMD**: Specifies the command to run when the container starts.

---

### **How to Build and Run Containers**

1. **Build an Image**:
   ```bash
   docker build -t my-app .
   ```
   - `-t my-app` tags the image with the name `my-app`.
   - `.` specifies the current directory as the build context.

2. **Run a Container**:
   ```bash
   docker run -d -p 3000:3000 my-app
   ```
   - `-d` runs the container in detached mode.
   - `-p 3000:3000` maps port 3000 on the host to port 3000 in the container.

3. **View Running Containers**:
   ```bash
   docker ps
   ```

4. **Stop a Container**:
   ```bash
   docker stop <container_id>
   ```

---

### **Publishing to Docker Swarm**

Docker Swarm allows you to deploy and manage a cluster of Docker nodes. It supports scaling, load balancing, and container orchestration.

#### **Steps to Publish to Docker Swarm**

1. **Initialize a Swarm**:
   ```bash
   docker swarm init
   ```
   - Initializes the current node as the swarm manager.

2. **Create a `docker-compose.yml` File**:
   Define the services and configuration for your application. Example:
   ```yaml
   version: '3.8'
   services:
     web:
       image: my-app
       ports:
         - "3000:3000"
       deploy:
         replicas: 3
         restart_policy:
           condition: on-failure
   ```

3. **Deploy the Application**:
   ```bash
   docker stack deploy --compose-file docker-compose.yml my-app-stack
   ```

4. **Verify the Services**:
   ```bash
   docker service ls
   ```

5. **Scale Services**:
   ```bash
   docker service scale my-app-stack_web=5
   ```
   - Scales the service to 5 replicas.

---

### **Configuring Docker Volumes**

Volumes are the preferred way to persist data generated by Docker containers.

#### **Types of Volumes**
1. **Named Volumes**:
   - Managed by Docker.
   - Example:
     ```bash
     docker volume create my-volume
     docker run -v my-volume:/data my-app
     ```

2. **Bind Mounts**:
   - Maps a specific directory on the host to a container directory.
   - Example:
     ```bash
     docker run -v /path/on/host:/data my-app
     ```

#### **Using Volumes in Docker Compose**

In a `docker-compose.yml` file:
```yaml
version: '3.8'
services:
  app:
    image: my-app
    volumes:
      - my-volume:/app/data

volumes:
  my-volume:
```

#### **Inspecting and Managing Volumes**
1. List all volumes:
   ```bash
   docker volume ls
   ```

2. Inspect a specific volume:
   ```bash
   docker volume inspect my-volume
   ```

3. Remove unused volumes:
   ```bash
   docker volume prune
   ```

---

### **Summary of Commands**

| Command                            | Description                                   |
|------------------------------------|-----------------------------------------------|
| `docker build -t <name> .`         | Build a Docker image from a `Dockerfile`.     |
| `docker run -d -p <host>:<container>` | Run a container in detached mode.         |
| `docker ps`                        | List running containers.                     |
| `docker stop <container_id>`       | Stop a running container.                    |
| `docker swarm init`                | Initialize a Docker Swarm.                   |
| `docker stack deploy ...`          | Deploy a stack to a Swarm.                   |
| `docker volume create <name>`      | Create a new Docker volume.                  |
| `docker volume ls`                 | List all Docker volumes.                     |
| `docker volume prune`              | Remove unused volumes.                       |

---

### **Best Practices**
- Use `.dockerignore` to exclude unnecessary files (e.g., `.git`, `node_modules`).
- Always use specific tags for base images (e.g., `node:14` instead of `node:latest`).
- Keep images small by using multi-stage builds.
- Use Docker Compose for multi-container applications.

---

Let me know if you'd like more detailed examples or clarifications on any section!
